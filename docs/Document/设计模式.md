# 设计模式

## 01 设计模式概述

### ✍**定义与重要性**

✅**解决特定问题的优秀解决方案**

1.设计模式提供经过验证的解决方案框架，减少开发时间。

2.它们促进代码复用，提高开发效率和软件质量。 

3.设计模式有助于团队沟通，确保设计的一致性和可维护性



✅**优化代码：重用、维 护、扩展 简捷高效**

1.设计模式通过提供通用解决方案，减少重复代码，提高代码复用性，降低维护成本。

2.采用设计模式，使得系统结构更清晰，易于扩展新功能，增强系统的可扩展性。



### ✍**设计模式的分类**

✅**创建型**

创建型模式关注对象的创建过程，如单例模式确保一个类只有一个实例。

**✅结构型**

结构型模式涉及对象的组合和结构，如适配器模式使接口不兼容的类能够合作。

✅**行为型**

### **✍设计模式的历史与发展**

**✅起源**

设计模式源于建筑，由Christopher Alexander提出，Erich Gamma等人在软件工程中提出23种应用模式。

**✅演进**

设计模式源自建筑领域，经Christopher Alexander提出，后发展为软件设计关键工具。

**✅分类**

1.**创建型模式：**关注对象创建过程，提高灵活性。

2.**结构型模式：**关注类和对象的组合，优化结构

**✅应用**

1.设计模式提升软件可维护性和可扩展性。

2.应用于解决实际开发中的常见问题



## 02 创建型模式详解



### ✍**一、简单工厂模式**

**✅定义**

简单工厂模式是一种创建型设计模式，用于创建对象。

**✅实现方法**

定义一个工厂类，根据输入选择创建不同子类实例。客户端无需直接实例化对象，简化了对象创建过程。

**✅优点**

简单工厂模式通过一个工厂类创建对象，简化了客户端代码，易于维护和扩展。

**✅缺点**

违反了开闭原则，增加新产品时需要修改工厂类，不够灵活。

**✅应用场景举例**

1.简单工厂模式适用于创建对象数量不多、种类固定的情况，如配置文件解析器。

2.在简单的应用中，如日志记录器，使用简单工厂可以集中管理日志级别和格式的创建。



### ✍**二、工厂方法模式**

✅**定义与实现方式**

工厂方法模式是一种创建型设计模式，它定义了一个创建对象的接口，但让子类决定实例化哪一个类。工厂方法让类的实例化推迟到子类中进行。实现方式是通过创建一个工厂接口和多个具体工厂类，每个具体工厂类负责创建一种特定的产品对象。

✅**与简单工厂模式的不同**

1.工厂方法模式引入了工厂接口和具体工厂类，每个具体工厂负责创建一种产品。

2.简单工厂模式只有一个工厂类，而工厂方法模式允许扩展新的产品类而无需修改现有代码。

**✅应用场景举例**

1.在图形用户界面(GUI)库中，根据用户选择动态创建

2.在游戏开发中，根据玩家选择

3.生成不同类型的敌人或道具。3. 在日志系统中，根据配置文件动态决定使用哪种日志记录方式。



### ✍**三、抽象工厂模式**

✅定义：创建一系列相关或相互依赖对象的接口。

✅实现方式：定义抽象接口，由具体工厂实现创建产品族。

✅优点：抽象工厂模式提供了一种方式，可以将客户端与具体类的实现分离，增加了系统的可扩展性和灵活性。

**✅应用场景与示例代码**

1.适用于创建一系列相关或相互依赖对象。

2.示例代码展示产品族的创建。

3.代码演示抽象工厂接口及实现



### ✍**四、建造者模式**

**✅定义与实现方式**

建造者模式是一种创建型设计模式，将对象构建与表示分离。涉及指挥者类和具体建造者类，指挥者指导构建，具体建造者负责实际构建，使相同过程可创建不同表示。

**✅结构清晰易维**

产品构建与表示分离的优点在于，它允许创建复杂对象的步骤独立于对象的最终表示形式。这种分离提高了代码的灵活性和可维护性，使得在不影响现有代码的情况下，可以轻松添加新的表示形式或修改构建过程。

✅**应用场景举例**

1. 在创建复杂对象时，如电脑组装，逐步构建各部件。
2. 当产品内部结构复杂，需要通过多个步骤创建。
3. 需要对产品进行定制化，允许用户选择不同组件。



### **✍五、原型模式**

✅**克隆定义：**复制生物体或信息的过程。

✅**克隆方式：**生物克隆、分子克隆等。

**✅深拷贝与浅拷贝的区别：**深拷贝复制对象全部内容，浅拷贝仅复制对象引用或顶层属性。

✅**应用场景与性能考虑：**应用场景广泛，性能稳定，高效，满足不同行业需求，确保运行流畅。



### ✍**六、单例模式**

✅**定义：**确保一个类只有一个实例，并提供全局访问点。

✅**实现方式：**私有构造函数，内部静态实例，公共访问方法。

✅**应用场景：**配置文件管理、数据库连接池等。

✅**线程安全关键：**

1. 单例模式在多线程环境下可能导致多个实例创建。
2. 解决方案包括使用同步锁、双重检查锁定等。
3. 需要考虑懒汉式与饿汉式在并发时的不同表现。

✅**应用场景举例**

1.**配置文件管理器：**确保全局只有一个配置文件实例，避免配置。

2.**数据库连接池：**单个数据库连接池实例管理所有数据库连接，提高效率。

3.**日志记录器：**统一日志记录，确保所有日志信息来自同一源头，标语追踪和管理。



## 03 结构型模式解析



### **✍一、适配器模式**

**✅定义与实现方式**

适配器模式是一种结构型设计模式，它允许将一个类的接口转换成客户期望的另一个接口。实现方式包括创建一个适配器类，实现目标接口，并在其中封装一个需要适配的类的实例。

✅**类适配器与对象适配器的选择**

1.**类适配器：**通过继承实现，适用于需要修改或扩展一个类的功能。

2. **对象适配器：**通过组合实现，适用于系统中存在多个类需要适配。

✅**应用场景举例**

1.旧系统接口与新系统不兼容时，适配器模式可实现两者对接。

2.当第三方库接口不符合项目需求时，通过适配器转换接口。



### ✍**二、组合模式**

**✅定义与实现方式**

组合模式（Composite Pattern）是一种结构型设计模式，允许将对象组合成树形结构来表现整体/部分的层次结构。实现时，创建一个抽象类或接口，定义包含子部件的方法，然后实现具体组件类，既可以是叶子节点，也可以是包含子节点的容器。容器类包含一个子部件列表，实现添加、删除和获取子部件的方法。通过这种方式，客户端可以统一处理单个对象和组合对象。

✅**透明组合与安全组合的选择**

1. 透明组合模式下，客户端无需区分处理单个对象与组合对象，简化了客户端代码。
2. 安全组合模式中，组件接口不暴露与组合相关的方法，增强了安全性。
3. 选择透明组合或安全组合取决于是否需要隐藏组合细节，以适应不同场景需求。

**✅应用场景举例**

1.组合模式在文件系统中应用广泛，如在文件夹和文件的管理中，可以将文件夹视为容器，文件视为叶子节点，实现对文件系统的统一操作。

2.在图形用户界面(GUI)开发中，组合模式可以用来构建组件的树形结构，例如，一个按钮可以包含多个子按钮，这样可以方便地对整个组件树进行操作，如启用、禁用或更新界面。



### **✍三、装饰器模式**

✅**装饰器与继承的比较**

1.装饰器模式提供动态扩展，继承则需静态定义。

2.装饰器避免类爆炸，继承可能导致子类泛滥。

3.装饰器更灵活，继承限制多且难以修改

**✅应用场景与示例代码**

装饰器模式用于动态给对象添加职责，不改变其结构。如日志、权限检查。示例中，ConcreteComponent被ConcreteDecoratorA装饰，增加额外行为。



### **✍四、桥接模式**

✅**定义：**将抽象与实现分离，使它们可以独立变化。

**✅实现方式：**通过接口或抽象类建立抽象层，实现层则具体实现。

**✅抽象分离，灵活高效：**

1. 提高系统的可扩展性，易于增加新的实现。



2. 降低类与类之间的耦合度，便于维护和管理。

**✅应用场景与示例代码：**

1. **应用场景：**系统需要独立于平台变化。
2. **示例代码：**定义抽象和实现接口。
3. **优点：**提高系统扩展性和灵活性





### ✍**五、外观模式**

**✅定义：**外观模式是一种结构型设计模式，它提供了一个统一的接口来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。

**✅实现方式：**通过创建一个外观类，该类提供简单的方法来调用子系统中的一组接口。客户端通过外观类与子系统交互，无需直接与复杂的子系统代码打交道

**✅减少系统间依赖的优点**

外观模式通过提供统一的接口简化了复杂系统的使用，从而减少了系统间的依赖。它允许客户端与子系统进行交互时，无需直接依赖子系统中的各个组件，这样不仅降低了客户端与子系统之间的耦合度，还提高了系统的可维护性和可扩展性。简而言之，外观模式使得系统间的交互更加简洁和高效。

**✅应用场景举例**

**1. 简化复杂系统：**外观模式通过提供统一接口简化对复杂系统各部分的访问，如在软件开发中整合多个子系统。

**2. 提高用户体验：**在用户界面设计中，外观模式可隐藏底层复杂性，提供简洁的操作界面，增强用户体验。

**3. 促进模块化：**在模块化开发中，外观模式帮助不同模块间通信，降低模块间的耦合度，便于维护和扩展



### **✍六、享元模式**

**✅定义：**享元模式通过共享对象减少内存占用，适用于大量相似对象的场景，通过对象池减少创建和销毁开销。

✅**实现方式：**创建享元工厂管理对象池，区分内部状态（共享）和外部状态（不可共享），通过享元接口访问共享数据。

**✅共享：便捷需审慎**

1. **优点：**减少内存占用，提高系统性能。
2. **注意：**需确保共享对象状态一致。
3. **注意：**避免过度共享，导致逻辑复杂

**✅应用场景举例**

1. **文本编辑器：**共享字符对象，减少内存占用。
2. **游戏开发：**共享游戏元素，提高性能。
3. **大型应用：**共享配置信息，简化管理



### ✍**七、代理模式**

✅**定义与实现方式：**控制对象访问的结构型设计，通过代理类引用原对象，实现相同接口或继承。

**✅静动代理：编译时/运行时**

静态代理在编译时确定代理类，而动态代理在运行时由JVM动态生成代理对象。

**✅应用场景与性能考虑**

代理模式优化网络通信，控制敏感对象访问，延迟加载提升性能。



## 04 行为型模式介绍



### **✍一、观察者模式**

**✅定义：**观察者模式定义了对象间的一种一对多依赖关系。

**✅实现方式：**通过注册和通知机制实现，当被观察对象状态改变时通知所有观察者。

**✅一对多，多对多观察关系**

1.一对多关系中，一个主题对应多个观察者，如新闻订阅。

2.多对多关系中，多个主题可被多个观察者订阅，如社交网络动态。

**✅应用场景举例**

1**.新闻发布系统：**实时更新订阅者。

2.**社交媒体动态推送：**通知关注者。

3.**股票交易监控：**实时价格变动通知



### **✍二、模板方法模式**

**✅定义与实现方式**

模板方法模式定义算法骨架，延迟部分步骤至子类。通过抽象类与模板方法，子类可重定义算法步骤，维持算法结构不变。实现算法变体，提高代码复用性。

**✅钩子方法的运用**

1. 钩子方法允许子类提供算法的特定实现，增强模板方法模式的灵活性。
2. 在模板方法中，钩子方法可以作为默认行为或条件判断，控制流程执行。

**✅应用场景与示例代码**

模板方法模式处理固定算法结构，但允许子类定制特定步骤。抽象类定义算法骨架，子类实现抽象方法。示例中，AbstractClass含模板方法，ConcreteClass定制步骤实现。



### **✍三、命令模式**

**✅定义与实现方式**

命令模式封装请求为对象，通过接口执行不同命令。涉及命令接口、具体命令类、接收者和调用者，实现行为参数化。

**✅命令的撤销与恢复功能**

1. 命令模式通过记录操作历史，实现撤销功能，恢复到之前状态。
2. 设计命令对象时，加入撤销和重做方法，以支持多次撤销与恢复。

✅**应用场景举例**

1. GUI工具箱中的菜单操作
2. 宏命令录制与回放
3. 事务性操作的撤销与重做



### **✍四、状态模式**

✅**定义与实现方式：**定义明确概念，实施具体方法，确保效果与预期一致，即为定义与实现之精髓。

**✅状态转换的控制逻辑：**状态转换的控制逻辑确保系统在不同状态间高效、准确地切换与执行操作。

**✅应用场景与示例代码：**应用场景广泛，示例代码简洁明了，助力高效开发与问题解决。



### **✍五、访问者模式**

**✅定义与实现方式：**定义访问接口，元素类接受访问者并调用其操作，实现对象结构元素的新操作添加。

**✅元素双分派机制：**元素与访问者的双重分派机制允许访问者对不同元素执行特定操作，通过在运行时动态绑定元素和操作，实现灵活扩展和维护。

**✅应用场景与性能考虑：**访问者模式适用于结构稳定、操作多变的场景，扩展性好且职责清晰，无需修改类结构，避免在元素类中添加方法。



### **✍六、备忘录模式**

**✅定义：**允许在不破坏封装的前提下，捕获对象的内部状态，并在需要时恢复到之前的状态。

✅**实现方式：**创建备忘录类存储对象状态，发起人负责创建和恢复状态，管理者负责备忘录的存取。

**✅备忘录的存储与恢复功能**

1. 备忘录模式通过快照机制保存对象状态，实现数据的存储。
2. 提供恢复接口，允许将对象状态恢复到之前保存的任何时刻。

**✅应用场景举例**

1. 文档编辑软件中撤销操作：备忘录模式允许用户保存文档状态，快速恢复到之前的编辑点。
2. 游戏存档功能：玩家可以保存当前游戏进度，以便随时加载并继续游戏。



### **✍七、解释器模式**

**✅定义：**解释器模式定义语言的文法，通过接口定义解释方法，为文法规则创建类实现接口，并在类中实现解释逻辑。用于构建解释器解释特定语言句子。

**✅文法定义解析：**解释器模式通过定义一个文法规则集合和解释器，将复杂的语言表达式转化为简单结构，实现对表达式的解释。

**✅应用场景：**解释器模式适用于 特定类型的问题，如正则表达式解析、SQL解析等。 

✅**示例代码：**定义表达式接口和具体表达式类，实现解释方法， 构建解析树执行解释操作。



### ✍**八、策略模式**

✅**定义与实现方法：**策略模式封装算法，互换使用，不影响客户端。实现涉及策略接口、具体策略类和上下文类。客户端选择策略，通过上下文使用，实现算法变化与应用解耦。

✅**策略的选择与切换逻辑：**

1. **策略选择依据：**根据业务需求和场景确定策略。
2. **策略切换时机：**运行时根据条件动态切换策略。
3. **策略切换机制：**封装切换逻辑，确保切换平滑无误。

✅**应用场景举例：**

1. 在电商促销活动中，策略模式允许根据不同的节日或季节快速切换促销策略，如满减、打折、赠品等。
2. 在游戏开发中，策略模式可以用于实现不同的AI行为，如敌人的巡逻、追踪、逃跑等策略，易于扩展和维护。

## 05 设计模式案例应用



### **✍设计模式在实际项目中的应用举例**

**✅电商系统中的设计模式运用**

在电商系统中，使用单例模式管理数据库连接池，确保整个系统只有一个数据库连接实例，提高资源利用率和系统性能。

✅**游戏开发中的设计模式实践**

1. 单例模式：管理游戏全局资源，如音效、配置。
2. 策略模式：实现角色行为多样化，如AI决策。
3. 观察者模式：处理事件通知，如分数更新、状态变化。



### **✍设计模式结合新技术的应用**

✅**云计算中的设计模式**

1. 云服务架构中，工厂模式用于动态创建服务实例，以适应不同用户需求和负载变化。
2. 单例模式在云环境中确保全局只有一个服务实例，常用于管理数据库连接或会话状态。

**✅大数据处理中的设计模式选择**

1. **工厂模式：**用于构建复杂的大数据处理管道，简化组件创建和维护，提高系统的可扩展性。
2. **观察者模式：**在实时数据处理中，通过事件驱动模型实时更新数据状态，适用于流式计算场景。



### **✍设计模式的混合使用与优化**

**✅多种设计模式的组合运用策略**

1. 选择合适的模式组合以解决特定问题。
2. 确保模式间接口兼容，实现无缝集成。
3. 优化设计，避免过度设计和模式滥用