import{_ as s,c as a,o as n,a3 as e}from"./chunks/framework.zGi9i9Bf.js";const u=JSON.parse('{"title":"安卓高版本HTTPS抓包终极解决方案","description":"","frontmatter":{},"headers":[],"relativePath":"Document/网络安全/【抓包配置】/安卓高版本HTTPS抓包终极解决方案.md","filePath":"Document/网络安全/【抓包配置】/安卓高版本HTTPS抓包终极解决方案.md","lastUpdated":1717759497000}'),l={name:"Document/网络安全/【抓包配置】/安卓高版本HTTPS抓包终极解决方案.md"},p=e(`<h1 id="安卓高版本https抓包终极解决方案" tabindex="-1">安卓高版本HTTPS抓包终极解决方案 <a class="header-anchor" href="#安卓高版本https抓包终极解决方案" aria-label="Permalink to &quot;安卓高版本HTTPS抓包终极解决方案&quot;">​</a></h1><p>虽然市面上有好多抓包工具，但是 Android 高版本都需要安装抓包工具的证书到系统目录，才能抓 https 协议的包。本文就以 <code>Charles</code>这个抓包工具来介绍，如何安装证书到 Android 的系统目录，实现 https 抓包。</p><h3 id="修改证书名称" tabindex="-1">修改证书名称 <a class="header-anchor" href="#修改证书名称" aria-label="Permalink to &quot;修改证书名称&quot;">​</a></h3><p>启动 Charles，通过菜单栏中的 <code>Help → SSL Proxying → Save Charles Root Certificate…</code> 将 Charles 的证书导出。使用 OpenSSL 查看证书在 Android 系统中对应的文件名，并重命名证书文件</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">openssl</span><span style="color:#98C379;"> x509</span><span style="color:#D19A66;"> -subject_hash_old</span><span style="color:#D19A66;"> -in</span><span style="color:#98C379;"> charles-ssl-proxying-certificate.pem</span><span style="color:#ABB2BF;"> | </span><span style="color:#61AFEF;">head</span><span style="color:#D19A66;"> -n</span><span style="color:#D19A66;"> 1</span><span style="color:#7F848E;font-style:italic;">  #cdfb61bc</span></span>
<span class="line"><span style="color:#61AFEF;">mv</span><span style="color:#98C379;"> charles-ssl-proxying-certificate.pem</span><span style="color:#98C379;"> cdfb61bc.0</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="将证书安装到系统证书目录下" tabindex="-1">将证书安装到系统证书目录下 <a class="header-anchor" href="#将证书安装到系统证书目录下" aria-label="Permalink to &quot;将证书安装到系统证书目录下&quot;">​</a></h3><p>使用 adb push 命令将我们的证书文件放到 SD 卡中</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">adb</span><span style="color:#98C379;"> push</span><span style="color:#98C379;"> cdfb61bc.0</span><span style="color:#98C379;"> /sdcard/Download</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>使用 adb 连接手机并切换到 root 用户</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">adb</span><span style="color:#98C379;"> shell</span></span>
<span class="line"><span style="color:#61AFEF;">su</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>将证书文件移动到 <code>/system/etc/security/cacerts</code> 目录下，由于 <code>/system</code> 默认是只读的，所以要先重新挂载为其添加写入权限</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>cat /proc/mounts  #查看挂载信息，这里我的 /system 是直接挂载到 / 的</span></span>
<span class="line"><span></span></span>
<span class="line"><span>mount -o rw,remount /</span></span>
<span class="line"><span>mv /sdcard/Download/cdfb61bc.0  /system/etc/security/cacerts</span></span>
<span class="line"><span>chmod 644 /system/etc/security/cacerts/cdfb61bc.0  #设置文件权限</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>如果👆的步骤你都能成功，就不用继续往下看了。</p><h3 id="终极解决方案" tabindex="-1">终极解决方案 <a class="header-anchor" href="#终极解决方案" aria-label="Permalink to &quot;终极解决方案&quot;">​</a></h3><p>我用我手上的手机都试了一下，用上面的方式安装正式，发现不能成功，一直提示 <code>Read-only file system</code>，但是<code>HttpToolkit</code>这个软件却可以通过 <code>Android Device Via ADB</code>来抓 https 的包。它是怎么实现的呢？这下又开始了漫长的谷歌之旅，最后在他们官网找到一篇文章，详细讲述了 <strong>通过有root权限的adb</strong> 来写入系统证书的神奇方案。</p><ol><li>通过 ADB 将 HTTP Toolkit CA 证书推送到设备上。</li><li>从 /system/etc/security/cacerts/ 中复制所有系统证书到临时目录。</li><li>在 /system/etc/security/cacerts/ 上面挂载一个 tmpfs 内存文件系统。这实际上将一个可写的全新空文件系统放在了 /system 的一小部分上面。将复制的系统证书移回到该挂载点。</li><li>将 HTTP Toolkit CA 证书也移动到该挂载点。</li><li>更新临时挂载点中所有文件的权限为 644，并将系统文件的 SELinux 标签设置为 system_file，以使其看起来像是合法的 Android 系统文件。</li></ol><p>关键点就是挂载一个 <strong>内存文件系统</strong>，太有才了。具体命令如下</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;"># 创建一个独立的临时目录，用于存储当前的证书</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"># 如果不这样做，在我们添加挂载后将无法再读取到当前的证书。</span></span>
<span class="line"><span style="color:#61AFEF;">mkdir</span><span style="color:#D19A66;"> -m</span><span style="color:#D19A66;"> 700</span><span style="color:#98C379;"> /data/local/tmp/htk-ca-copy</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"># 复制现有的证书到临时目录</span></span>
<span class="line"><span style="color:#61AFEF;">cp</span><span style="color:#98C379;"> /system/etc/security/cacerts/</span><span style="color:#E5C07B;">*</span><span style="color:#98C379;"> /data/local/tmp/htk-ca-copy/</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"># 在系统证书文件夹之上创建内存挂载点</span></span>
<span class="line"><span style="color:#61AFEF;">mount</span><span style="color:#D19A66;"> -t</span><span style="color:#98C379;"> tmpfs</span><span style="color:#98C379;"> tmpfs</span><span style="color:#98C379;"> /system/etc/security/cacerts</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"># 将之前复制的证书移回内存挂载点中，确保继续信任这些证书</span></span>
<span class="line"><span style="color:#61AFEF;">mv</span><span style="color:#98C379;"> /data/local/tmp/htk-ca-copy/</span><span style="color:#E5C07B;">*</span><span style="color:#98C379;"> /system/etc/security/cacerts/</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"># 将新的证书复制进去，以便我们也信任该证书</span></span>
<span class="line"><span style="color:#61AFEF;">cp</span><span style="color:#98C379;"> /data/local/tmp/c88f7ed0.0</span><span style="color:#98C379;"> /system/etc/security/cacerts/</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"># 更新权限和SELinux上下文标签，确保一切都和之前一样可读</span></span>
<span class="line"><span style="color:#61AFEF;">chown</span><span style="color:#98C379;"> root:root</span><span style="color:#98C379;"> /system/etc/security/cacerts/</span><span style="color:#E5C07B;">*</span></span>
<span class="line"><span style="color:#61AFEF;">chmod</span><span style="color:#D19A66;"> 644</span><span style="color:#98C379;"> /system/etc/security/cacerts/</span><span style="color:#E5C07B;">*</span></span>
<span class="line"><span style="color:#61AFEF;">chcon</span><span style="color:#98C379;"> u:object_r:system_file:s0</span><span style="color:#98C379;"> /system/etc/security/cacerts/</span><span style="color:#E5C07B;">*</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"># 删除临时证书目录</span></span>
<span class="line"><span style="color:#61AFEF;">rm</span><span style="color:#D19A66;"> -r</span><span style="color:#98C379;"> /data/local/tmp/htk-ca-copy</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p><strong>注意：由于是内存文件系统，所以重启手机后就失效了。可以将以上命令写成 shell 脚本，需要抓包的时候执行下就可以了。</strong></p>`,19),c=[p];function o(t,r,i,d,y,b){return n(),a("div",null,c)}const h=s(l,[["render",o]]);export{u as __pageData,h as default};
