import{_ as a,c as s,o as n,a3 as e}from"./chunks/framework.zGi9i9Bf.js";const p="/ProgramLearnNotes/assets/640.CQuoA0Pr.webp",l="/ProgramLearnNotes/assets/640-1714155480860-489.CoAAoJsB.webp",r="/ProgramLearnNotes/assets/640-1714155480860-490.BLT04MbP.webp",i="/ProgramLearnNotes/assets/640-1714155480860-491.BjmRJaX9.webp",o="/ProgramLearnNotes/assets/640-1714155480860-492.DgRJGI_h.webp",t="/ProgramLearnNotes/assets/640-1714155480860-493.C2epu7Oo.webp",c="/ProgramLearnNotes/assets/640-1714155480860-494.VwaQ6y4i.webp",d="/ProgramLearnNotes/assets/640-1714155480860-495.DjTwdqaW.webp",b="/ProgramLearnNotes/assets/640-1714155480860-496.CCcMqMzG.webp",q=JSON.parse('{"title":"APP逆向破解教程","description":"","frontmatter":{},"headers":[],"relativePath":"Document/网络安全/【逆向破解】/APP逆向破解教程.md","filePath":"Document/网络安全/【逆向破解】/APP逆向破解教程.md","lastUpdated":1717759497000}'),m={name:"Document/网络安全/【逆向破解】/APP逆向破解教程.md"},h=e('<h1 id="app逆向破解教程" tabindex="-1">APP逆向破解教程 <a class="header-anchor" href="#app逆向破解教程" aria-label="Permalink to &quot;APP逆向破解教程&quot;">​</a></h1><p>原文：<a href="https://www.52pojie.cn/thread-1904103-1-1.html" target="_blank" rel="noreferrer">某灰产收费虚拟定位APP逆向破解教程 - 『移动安全区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><h2 id="环境和工具" tabindex="-1">环境和工具 <a class="header-anchor" href="#环境和工具" aria-label="Permalink to &quot;环境和工具&quot;">​</a></h2><h3 id="环境" tabindex="-1">环境 <a class="header-anchor" href="#环境" aria-label="Permalink to &quot;环境&quot;">​</a></h3><ul><li>• MacOS 13.6.3</li><li>• Java 20.0.2</li><li>• Python 3.11.5</li></ul><h3 id="工具" tabindex="-1">工具 <a class="header-anchor" href="#工具" aria-label="Permalink to &quot;工具&quot;">​</a></h3><ul><li>• Android Studio 2022.3.1 Patch 2</li><li>• JEB 5.2.0.202308292043</li><li>• frida 16.1.8</li><li>• apktool 2.9.3</li><li>• shell-tools</li></ul><h2 id="破解过程" tabindex="-1">破解过程 <a class="header-anchor" href="#破解过程" aria-label="Permalink to &quot;破解过程&quot;">​</a></h2><h3 id="逆向分析" tabindex="-1">逆向分析 <a class="header-anchor" href="#逆向分析" aria-label="Permalink to &quot;逆向分析&quot;">​</a></h3><p>首先打开未破解的APP，映入眼帘的就是要求输入卡密才能使用......（什么CrackMe？）</p><p><img src="'+p+'" alt="图片"></p><p>先打开JEB，搜索字符串“登录”，很快啊，在<code>yz.local</code>下就找到了：</p><p><img src="'+l+'" alt="图片"></p><p>初步判断<code>yz.local</code>就是和登录以及卡密获取、试用逻辑啥的相关的一个类。可以看到类中的成员变量<code>local.host</code>和<code>local.host2</code>这两个域名和IP（图中已打码部分），初步判断这个就是来**远程判断是否拥有卡号（卡密）**的，这样的话，应该有和API直接交互的逻辑。往下找：</p><p><img src="'+r+'" alt="图片"></p><p>果然啊，有个和API进行交互的方法。而且通过构造传递给API的参数（在别的方法中可以找到需要传递的参数），可以确认这个API就是检验卡号是否正确以及有没有过期的（幽默订阅制）。</p><p>那么目前可以确定的就是卡号的合法性验证逻辑在<strong>远程，并且需要联网访问</strong>，但是返回的值判断却在本地（因为API只返回状态值），因此要绕过理论是可以通过发伪包的（没试过）。</p><p>现在还要确认的是实现这个虚拟定位功能需不需要和远程的某个API进行交互。通过购买了卡号的朋友断网验证：<strong>虚拟定位的逻辑是写在本地的</strong>。这就有些搞笑了，这也就意味着只有卡号验证是要通过远程API来的，而实际的功能部分却写在了本地。换言之，<strong>卡号验证只是一个限制，只要绕过了这个限制，就能免费正常使用虚拟定位的功能。</strong></p><p>那么要做的事情就很简单了，绕过卡号验证，也就是crack掉最开始的那个输入框。经过简单的寻找，发现这个框的逻辑是写在<code>local.load</code>这个方法里的：</p><p><img src="'+i+`" alt="图片"></p><h3 id="frida-hook" tabindex="-1">frida hook <a class="header-anchor" href="#frida-hook" aria-label="Permalink to &quot;frida hook&quot;">​</a></h3><p>还是个public的静态方法，写个frida hook验证一下：</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>import frida  # 导入frida模块</span></span>
<span class="line"><span>import sys    # 导入sys模块</span></span>
<span class="line"><span></span></span>
<span class="line"><span>jscode = &#39;&#39;&#39;</span></span>
<span class="line"><span>    Java.perform(function(){</span></span>
<span class="line"><span>        var targetClass = Java.use(&#39;yz.local&#39;);</span></span>
<span class="line"><span>        targetClass.load.implementation = function() {</span></span>
<span class="line"><span>            console.log(&#39;hack&#39;);</span></span>
<span class="line"><span>            return;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    });</span></span>
<span class="line"><span>&#39;&#39;&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>def on_message(message,data): #js中执行send函数后要回调的函数</span></span>
<span class="line"><span>    print(message)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 获取设备</span></span>
<span class="line"><span>device = frida.get_usb_device()</span></span>
<span class="line"><span># 应用程序包名</span></span>
<span class="line"><span>app_name = &#39;xu.nx.zheror&#39;</span></span>
<span class="line"><span># 启动应用程序并获取其进程 ID</span></span>
<span class="line"><span>pid = device.spawn([app_name])</span></span>
<span class="line"><span># 附加到应用程序进程</span></span>
<span class="line"><span>session = device.attach(pid)</span></span>
<span class="line"><span># 创建并加载 Frida 脚本</span></span>
<span class="line"><span>script = session.create_script(jscode)</span></span>
<span class="line"><span># 添加消息监听器</span></span>
<span class="line"><span>script.on(&#39;message&#39;, on_message)</span></span>
<span class="line"><span># 加载脚本</span></span>
<span class="line"><span>script.load()</span></span>
<span class="line"><span># 从 spawn 状态过渡到运行状态</span></span>
<span class="line"><span>device.resume(pid)</span></span>
<span class="line"><span># 保持 Python 脚本运行，直到手动中断或者其他操作</span></span>
<span class="line"><span>sys.stdin.read()</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><p>跑一下，成功绕过，只能说过于幽默了：</p><p><img src="`+o+'" alt="图片"></p><h3 id="crack" tabindex="-1">crack <a class="header-anchor" href="#crack" aria-label="Permalink to &quot;crack&quot;">​</a></h3><p>决定采用最简单粗暴也最有效的方法：<strong>解包，硬改smali，重签名打包</strong>。</p><p>解包和签名打包的脚本用的是：<a href="https://github.com/8enet/shell-tools" target="_blank" rel="noreferrer">https://github.com/8enet/shell-tools</a></p><p>首先是解包，执行：</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>./decompile.sh ***.apk    # ***.apk是安装包路径</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>不出意外的话会得到类似这样的结果：</p><p><img src="'+t+'" alt="图片"></p><p>然后找到<code>apk解包后的目录/smali_classes9/yz/local.smali</code>打开，搜索“load”找到smali对应的方法，把方法中其都删掉，只保留一个.locals和return，修改后的如下图：</p><p><img src="'+c+'" alt="图片"></p><p>然后保存修改后的smali文件。</p><p>最后是重签名打包，执行：</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>./rebuild.sh ***    # ***是解包后的路径</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><strong>失败的话记得用keytool先生成keystore的签名文件，然后修改<code>rebuild.sh</code>里的keystore路径等信息</strong>，成功的话会得到类似这样的结果：</p><p><img src="'+d+'" alt="图片"></p><p>将修改后重签名的apk安装到实机上测试（如果之前有安装过的话记得卸载，不然会有签名冲突），赋予相应权限后可以看到虚拟定位的功能可以正常使用，破解成功：</p><p><img src="'+b+'" alt="图片"></p><h2 id="后记" tabindex="-1">后记 <a class="header-anchor" href="#后记" aria-label="Permalink to &quot;后记&quot;">​</a></h2><p>没有暗桩、加壳、加密、混淆，判断逻辑写在Java层，它真我哭。是有些幽默了，破解难度感觉还没我逆向课程设计高，这种也就只能赚不懂技术的人的钱了。（这下断人财路了）</p><h3 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h3><ul><li>• 修改smali插入代码：</li><li><a href="https://blog.zzzmode.com/2017/07/27/modify_smali_code_part1/" target="_blank" rel="noreferrer">https://blog.zzzmode.com/2017/07/27/modify_smali_code_part1/</a></li><li>• frida入门总结：</li><li><a href="https://www.52pojie.cn/thread-1128884-1-1.html" target="_blank" rel="noreferrer">https://www.52pojie.cn/thread-1128884-1-1.html</a></li><li>• frida hook 工具基础使用(一)：</li><li><a href="https://www.52pojie.cn/thread-1746855-1-1.html" target="_blank" rel="noreferrer">https://www.52pojie.cn/thread-1746855-1-1.html</a></li><li>• 8enet/shell-tools：</li><li><a href="https://github.com/8enet/shell-tools" target="_blank" rel="noreferrer">https://github.com/8enet/shell-tools</a></li></ul>',45),u=[h];function _(g,P,f,k,w,v){return n(),s("div",null,u)}const y=a(m,[["render",_]]);export{q as __pageData,y as default};
